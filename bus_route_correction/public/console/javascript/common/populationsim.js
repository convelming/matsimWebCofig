// PopulationSim UI extensions for matsimWebViz-master console
// - Additive only: extends existing ui.custom.console.call with PopulationSim-specific logic
// - Generated by migrating from legacy WebBasedMatsim UI

(function () {
  if (!window.ui || !ui.custom || !ui.custom.console || !ui.custom.console.call) return;

  Object.assign(ui.custom.console.call, {
showFastExampleValidationMsg: function (formId, html) {
      if (!formId) formId = "pop_fastexmaple";
      var tabName = "p_form_" + formId + "_fastExampleValidationMsg";
      var host = $("*[name='" + tabName + "']").closest(".p-form");
      if (host.length) host.css("display", "block");
      var errorDom = $("*[name='" + tabName + "']")
        .parent()
        .siblings("*[name='p_form_error_msg']");
      if (errorDom.length) {
        errorDom.html(html || "");
        errorDom.css("display", html ? "block" : "none");
      }
    },
    hideFastExampleValidationMsg: function (formId) {
      if (!formId) formId = "pop_fastexmaple";
      var tabName = "p_form_" + formId + "_fastExampleValidationMsg";
      var host = $("*[name='" + tabName + "']").closest(".p-form");
      if (host.length) host.css("display", "none");
      var errorDom = $("*[name='" + tabName + "']")
        .parent()
        .siblings("*[name='p_form_error_msg']");
      if (errorDom.length) {
        errorDom.html("");
        errorDom.css("display", "none");
      }
    },
    fastExampleAreaFileChecked: function (params) {
      var formId = (params && params.formId) || this.formId || "pop_fastexmaple";
      var key = (params && params.key) || this.key || "fastAreaFile";
      var file = params && params.file;

      // File cleared -> hide message and let verify handle required-ness via `if`.
      if (!file) {
        ui.custom.console.call.hideFastExampleValidationMsg(formId);
        return;
      }

      var name = (file && file.name ? file.name : "").toString().toLowerCase();
      var ok = name.endsWith(".zip") || name.endsWith(".rar");
      if (ok) {
        ui.custom.console.call.hideFastExampleValidationMsg(formId);
        return;
      }

      // Invalid extension -> clear selection to force re-pick.
      var base = "p_form_" + formId + "_" + key;
      $("#" + base + "File").val("");
      $("input[name='" + base + "Text']").val("");
      ui.custom.console.call.showFastExampleValidationMsg(formId, "错误：范围文件必须为 zip/rar 格式。");
    },
    geoCsvChecked: function (params) {
      var formId = (params && params.formId) || this.formId;
      var file = params && params.file;
      var levelNamesKey = "geoLevelNames";
      var levelCountKey = "geoLevelCount";

      if (!formId) return;

      if (!file) {
        ui.parts.form.element.setData(formId, levelNamesKey, "");
        ui.parts.form.element.setData(formId, levelCountKey, "0");
        ui.custom.console.geoLevels = [];
        ui.custom.console.call.setGeoLevelsOnShape(formId, []);
        var geoShapeId = ui.custom.console.call.getFormShapeId(formId);
        var connected = ui.custom.console.call.getTotalControlConnectedShapeIdsByType(geoShapeId, "geo_control");
        if (connected.length) {
          ui.custom.console.call.updateGeoControlForm([], true);
          ui.custom.console.call.setGeoControlLevels([]);
          ui.custom.console.call.validateGeoControlNumHh("geo_control");
        }
        ui.custom.console.call.refreshTotalControlGeographyOptions();
        ui.custom.console.call.validateSeedInputFiles("seed_input");
        return;
      }

      var reader = new FileReader();
      reader.onload = function (evt) {
        var text = (evt.target && evt.target.result) || "";
        var headers = ui.custom.console.call.parseCsvHeader(text);
        var headerText = headers.join(", ");
        ui.parts.form.element.setData(formId, levelNamesKey, headerText);
        ui.parts.form.element.setData(formId, levelCountKey, headers.length.toString());
        ui.custom.console.geoLevels = headers.slice(0);
        ui.custom.console.call.setGeoLevelsOnShape(formId, headers.slice(0));
        var geoShapeId = ui.custom.console.call.getFormShapeId(formId);
        var connected = ui.custom.console.call.getTotalControlConnectedShapeIdsByType(geoShapeId, "geo_control");
        if (connected.length) {
          ui.custom.console.call.updateGeoControlForm(headers, true);
          ui.custom.console.call.setGeoControlLevels(headers);
          ui.custom.console.call.validateGeoControlNumHh("geo_control");
        }
        ui.custom.console.call.refreshTotalControlGeographyOptions();
        ui.custom.console.call.validateSeedInputFiles("seed_input");
      };
      reader.onerror = function () {
        ui.parts.form.element.setData(formId, levelNamesKey, "");
        ui.parts.form.element.setData(formId, levelCountKey, "0");
        ui.custom.console.geoLevels = [];
        ui.custom.console.call.setGeoLevelsOnShape(formId, []);
        var geoShapeId = ui.custom.console.call.getFormShapeId(formId);
        var connected = ui.custom.console.call.getTotalControlConnectedShapeIdsByType(geoShapeId, "geo_control");
        if (connected.length) {
          ui.custom.console.call.updateGeoControlForm([], true);
          ui.custom.console.call.setGeoControlLevels([]);
          ui.custom.console.call.validateGeoControlNumHh("geo_control");
        }
        ui.custom.console.call.refreshTotalControlGeographyOptions();
        ui.custom.console.call.validateSeedInputFiles("seed_input");
      };
      reader.readAsText(file);
    },
    seedUpload: function (data) {
      ui.custom.console.call.upload.call(this, data);
      if (data && data.success == true) {
        // If backend changes/sanitizes file names, keep header maps accessible
        // by duplicating parsed headers under the new base-name key.
        var prevName = "";
        if (this && this.formId && this.key) {
          var shapeId = ui.custom.console.call.getFormShapeId(this.formId);
          var snap = ui.custom.console.call.getShapeSnapshotById(shapeId);
          prevName = snap && snap[this.key] ? snap[this.key] : "";
        }

        var fileName = data.data;
        // Persist on the bound seed_input node so downstream dropdowns can read it from the graph.
        if (this && this.formId && this.key) ui.custom.console.call.setShapeOtherValue(this.formId, this.key, fileName);

        if (prevName && fileName && this && this.formId) {
          var oldKey = ui.custom.console.call.getFileBaseNameNoExt(prevName).replace(/^seed_/i, "");
          var newKey = ui.custom.console.call.getFileBaseNameNoExt(fileName).replace(/^seed_/i, "");
          if (oldKey && newKey && oldKey !== newKey) {
            var shapeId2 = ui.custom.console.call.getFormShapeId(this.formId);
            var snap2 = ui.custom.console.call.getShapeSnapshotById(shapeId2);
            var map = snap2 && snap2.seedTableHeaders ? snap2.seedTableHeaders : null;
            var headers = map && map[oldKey];
            if ($.isArray(headers) && headers.length) {
              ui.custom.console.call.setSeedTableHeadersOnShape(this.formId, newKey, headers);
            }
          }
        }

        ui.custom.console.call.refreshTotalControlSeedTableOptions();
      }
    },
    seedFileChecked: function (params) {
      // Capture local file name immediately (without requiring upload/finish) so downstream dropdowns can populate.
      var formId = (params && params.formId) || this.formId;
      if (!formId) return;
      var file = params && params.file;
      var key = (params && params.key) || this.key;
      if (!key) return;

      // File cleared -> clear cached file name and re-validate.
      if (!file) {
        ui.custom.console.call.setShapeOtherValue(formId, key, "");
        ui.custom.console.call.refreshTotalControlSeedTableOptions();
        ui.custom.console.call.validateSeedInputFiles(formId);
        return;
      }

      var fileName = file && file.name ? file.name : "";
      if (fileName) ui.custom.console.call.setShapeOtherValue(formId, key, fileName);

      // Also parse and store CSV headers for expression autocomplete.
      var tableKey = ui.custom.console.call.getFileBaseNameNoExt(fileName).replace(/^seed_/i, "");
      if (tableKey) {
        var reader = new FileReader();
        reader.onload = function (evt) {
          var text = (evt.target && evt.target.result) || "";
          var headers = ui.custom.console.call.parseCsvHeader(text);
          ui.custom.console.call.setSeedTableHeadersOnShape(formId, tableKey, headers);
        };
        reader.onerror = function () {
          ui.custom.console.call.setSeedTableHeadersOnShape(formId, tableKey, []);
        };
        try {
          var head = file.slice ? file.slice(0, 256 * 1024) : file;
          reader.readAsText(head);
        } catch (e) {
          reader.readAsText(file);
        }
      }

      ui.custom.console.call.refreshTotalControlSeedTableOptions();
      ui.custom.console.call.validateSeedInputFiles(formId);
      // pop_run (no settings.yaml) uses seed_households headers for column selection UI.
      if ($("#p_window_pop_run").length && $("#p_window_pop_run").css("display") != "none") {
        ui.custom.console.call.initPopRunForm("pop_run");
      }
    },
    totalControlCsvChecked: function (params) {
      var formId = (params && params.formId) || this.formId || "total_control";
      var file = params && params.file;
      var key = (params && params.key) || this.key;
      if (!key) key = "controlCsvFile";

      if (!file) {
        // When file is cleared, reset validation so "完成" is blocked until it passes again.
        ui.custom.console.call.setShapeOtherValue(formId, "totalControlValidationPassed", "false");
        ui.custom.console.call.setTotalControlValidationPassed(formId, false);
        ui.custom.console.call.hideTotalControlValidationMsg(formId);
        return;
      }

      ui.custom.console.call.validateTotalControlConfig(formId);
    },
    getFormSelectedFile: function (formId, key) {
      if (!formId || !key) return null;
      var fileInputId = "p_form_" + formId + "_" + key + "File";
      var dom = $("#" + fileInputId);
      return dom[0] && dom[0].files ? dom[0].files[0] : null;
    },
    setSeedInputValidationPassed: function (formId, passed) {
      if (!formId) return;
      var inputName = "p_form_" + formId + "_seedValidationPassed";
      $("input[name='" + inputName + "']").val(passed ? "true" : "false");
    },
    showSeedInputValidationError: function (formId, html) {
      if (!formId) return;
      var tabName = "p_form_" + formId + "_seedValidationMsg";
      var host = $("*[name='" + tabName + "']").closest(".p-form");
      if (host.length) host.css("display", "block");
      var errorDom = $("*[name='" + tabName + "']")
        .parent()
        .siblings("*[name='p_form_error_msg']");
      if (errorDom.length) {
        errorDom.html(html || "");
        errorDom.css("display", html ? "block" : "none");
      }
    },
    hideSeedInputValidationError: function (formId) {
      if (!formId) return;
      var tabName = "p_form_" + formId + "_seedValidationMsg";
      var host = $("*[name='" + tabName + "']").closest(".p-form");
      if (host.length) host.css("display", "none");
      var errorDom = $("*[name='" + tabName + "']")
        .parent()
        .siblings("*[name='p_form_error_msg']");
      if (errorDom.length) {
        errorDom.html("");
        errorDom.css("display", "none");
      }
    },
    normalizeCsvHeaderKey: function (name) {
      var s = (name || "").toString().trim().toLowerCase();
      s = s.replace(/\s+/g, "_");
      s = s.replace(/[^a-z0-9_]+/g, "_");
      s = s.replace(/_+/g, "_").replace(/^_+|_+$/g, "");
      return s;
    },
    normalizeHeaderLoose: function (name) {
      // Keep unicode; only trim and lower-case for case-insensitive matching (e.g. ZONE vs zone).
      return (name || "").toString().trim().toLowerCase();
    },
    parseCsvLine: function (line) {
      var out = [];
      var current = "";
      var inQuotes = false;
      for (var i = 0; i < line.length; i++) {
        var ch = line.charAt(i);
        if (ch === '"') {
          if (inQuotes && line.charAt(i + 1) === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (ch === "," && !inQuotes) {
          out.push(current);
          current = "";
        } else {
          current += ch;
        }
      }
      out.push(current);
      for (var j = 0; j < out.length; j++) {
        var v = (out[j] || "").toString().trim();
        if (v.charAt(0) === '"' && v.charAt(v.length - 1) === '"') v = v.slice(1, -1);
        out[j] = v;
      }
      return out;
    },
    readFileAsText: function (file, maxBytes) {
      return new Promise(function (resolve, reject) {
        if (!file) return resolve("");
        var reader = new FileReader();
        reader.onload = function (evt) {
          resolve((evt.target && evt.target.result) || "");
        };
        reader.onerror = function () {
          reject(new Error("read_error"));
        };
        try {
          var blob = maxBytes && file.slice ? file.slice(0, maxBytes) : file;
          reader.readAsText(blob);
        } catch (e) {
          try {
            reader.readAsText(file);
          } catch (e2) {
            reject(e2);
          }
        }
      });
    },
    getCsvColumnUniqueValues: function (text, colIndex) {
      var set = new Set();
      if (!text) return set;
      var lines = text.split(/\r?\n/);
      var started = false;
      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (!started) {
          // Skip header (first non-empty line)
          if (line && line.trim() !== "") started = true;
          continue;
        }
        if (!line || line.trim() === "") continue;
        var cols = ui.custom.console.call.parseCsvLine(line);
        if (colIndex < 0 || colIndex >= cols.length) continue;
        var v = (cols[colIndex] || "").toString().trim();
        if (v) set.add(v);
      }
      return set;
    },
    validateSeedInputFiles: function (formId) {
      var self = ui.custom.console.call;
      if (!formId) return;

      self._seedValidateEpoch = self._seedValidateEpoch || {};
      var token = (self._seedValidateEpoch[formId] || 0) + 1;
      self._seedValidateEpoch[formId] = token;

      var hhFile = self.getFormSelectedFile(formId, "seedHouseholdFile");
      var perFile = self.getFormSelectedFile(formId, "seedPersonFile");

      // Default to "not passed" until both files pass validation.
      self.setSeedInputValidationPassed(formId, false);

      if (!hhFile || !perFile) {
        if (hhFile || perFile) {
          self.showSeedInputValidationError(formId, "错误：请同时选择 households 和 persons 两个CSV文件后再校验。");
        } else {
          self.hideSeedInputValidationError(formId);
        }
        return;
      }

      // Require a connected geo node (with parsed geoLevels) so we can detect which column is the seed geography.
      var seedShapeId = self.getFormShapeId(formId);
      var geoNodes = self.getTotalControlConnectedShapeIdsByType(seedShapeId, "geo");
      var geoLevels = [];
      if (geoNodes && geoNodes.length) {
        var node = geoNodes[0];
        if ($.isArray(node.geoLevels) && node.geoLevels.length) {
          geoLevels = node.geoLevels.slice(0);
        } else if (node.geoLevelNames && typeof node.geoLevelNames === "string") {
          geoLevels = node.geoLevelNames
            .split(",")
            .map(function (s) {
              return s.trim();
            })
            .filter(function (s) {
              return s;
            });
        }
      }
      if (!geoLevels.length) {
        self.showSeedInputValidationError(formId, "错误：请先将“地理层级文件输入”节点连接到该节点，并在地理层级节点上传CSV以读取层级名称。");
        return;
      }

      self.showSeedInputValidationError(formId, "<span style='color:#666666'>正在校验...</span>");

      Promise.all([self.readFileAsText(hhFile, 256 * 1024), self.readFileAsText(perFile, 256 * 1024)])
        .then(function (heads) {
          if (self._seedValidateEpoch[formId] !== token) return;
          var hhHeaders = self.parseCsvHeader(heads[0] || "");
          var perHeaders = self.parseCsvHeader(heads[1] || "");

          var hhNorm = hhHeaders.map(self.normalizeCsvHeaderKey);
          var perNorm = perHeaders.map(self.normalizeCsvHeaderKey);

          var missing = [];
          var needHh = ["hh_weight", "hh_id"];
          for (var i = 0; i < needHh.length; i++) if (hhNorm.indexOf(needHh[i]) === -1) missing.push(needHh[i]);
          var perMissing = [];
          if (perNorm.indexOf("hh_id") === -1) perMissing.push("hh_id");

          if (missing.length || perMissing.length) {
            var msgParts = [];
            if (missing.length) msgParts.push("households 缺少字段：<b>" + missing.join(", ") + "</b>");
            if (perMissing.length) msgParts.push("persons 缺少字段：<b>" + perMissing.join(", ") + "</b>");
            self.showSeedInputValidationError(formId, "错误：" + msgParts.join("<br/>"));
            return;
          }

          // Check that households contains at least one geography column name from geoLevels.
          var hhLoose = hhHeaders.map(self.normalizeHeaderLoose);
          var geoLoose = geoLevels.map(self.normalizeHeaderLoose);
          var matched = [];
          for (var g = 0; g < geoLevels.length; g++) {
            if (hhLoose.indexOf(geoLoose[g]) !== -1) matched.push(geoLevels[g]);
          }
          if (!matched.length) {
            self.showSeedInputValidationError(
              formId,
              "错误：households 中未找到地理层级列。请确保 households CSV 包含以下任意一列：<b>" + geoLevels.join(", ") + "</b>"
            );
            return;
          }

          var hhIdIdx = hhNorm.indexOf("hh_id");
          var perIdIdx = perNorm.indexOf("hh_id");

          return Promise.all([self.readFileAsText(hhFile), self.readFileAsText(perFile)]).then(function (texts) {
            if (self._seedValidateEpoch[formId] !== token) return;
            var hhText = texts[0] || "";
            var perText = texts[1] || "";

            var householdIds = self.getCsvColumnUniqueValues(hhText, hhIdIdx);
            var personIds = new Set();
            var invalidCount = 0;
            var invalidExamples = [];

            var perLines = perText.split(/\r?\n/);
            var started = false;
            for (var li = 0; li < perLines.length; li++) {
              var line = perLines[li];
              if (!started) {
                if (line && line.trim() !== "") started = true;
                continue;
              }
              if (!line || line.trim() === "") continue;
              var cols = self.parseCsvLine(line);
              if (perIdIdx < 0 || perIdIdx >= cols.length) continue;
              var v = (cols[perIdIdx] || "").toString().trim();
              if (!v) continue;
              personIds.add(v);
              if (!householdIds.has(v)) {
                invalidCount++;
                if (invalidExamples.length < 5 && invalidExamples.indexOf(v) === -1) invalidExamples.push(v);
              }
            }

            var missingCount = 0;
            var missingExamples = [];
            householdIds.forEach(function (id) {
              if (!personIds.has(id)) {
                missingCount++;
                if (missingExamples.length < 5) missingExamples.push(id);
              }
            });

            if (invalidCount || missingCount) {
              var msg = [];
              if (invalidCount) {
                msg.push("persons.hh_id 中存在不在 households.hh_id 中的ID（" + invalidCount + "条记录），例如：" + invalidExamples.join(", "));
              }
              if (missingCount) {
                msg.push("households.hh_id 中存在在 persons.hh_id 中缺失的ID（" + missingCount + "个），例如：" + missingExamples.join(", "));
              }
              self.showSeedInputValidationError(formId, "错误：" + msg.join("<br/>"));
              return;
            }

            // Persist the detected seed geography column for downstream usage if needed.
            self.setShapeOtherValue(formId, "seedGeographyColumn", matched[0]);
            self.showSeedInputValidationError(
              formId,
              "<span style='color:#1a7f37'>校验成功：已检测到 households 地理层级列 <b>" +
                matched.join(", ") +
                "</b>；并且 persons.hh_id 与 households.hh_id 完全对应。</span>"
            );
            self.setSeedInputValidationPassed(formId, true);
          });
        })
        .catch(function () {
          if (self._seedValidateEpoch[formId] !== token) return;
          self.setSeedInputValidationPassed(formId, false);
          self.showSeedInputValidationError(formId, "错误：读取CSV失败，请检查文件编码/格式。");
        });
    },
    setGeoControlValidationPassed: function (formId, passed) {
      if (!formId) formId = "geo_control";
      var inputName = "p_form_" + formId + "_geoControlValidationPassed";
      $("input[name='" + inputName + "']").val(passed ? "true" : "false");
      // Persist on the bound geo_control node so the state survives window rebuilds.
      ui.custom.console.call.setShapeOtherValue(formId, "geoControlValidationPassed", passed ? "true" : "false");
    },
    showGeoControlValidationMsg: function (formId, html) {
      if (!formId) formId = "geo_control";
      var tabName = "p_form_" + formId + "_geoControlValidationMsg";
      var host = $("*[name='" + tabName + "']").closest(".p-form");
      if (host.length) host.css("display", "block");
      var errorDom = $("*[name='" + tabName + "']")
        .parent()
        .siblings("*[name='p_form_error_msg']");
      if (errorDom.length) {
        errorDom.html(html || "");
        errorDom.css("display", html ? "block" : "none");
      }
    },
    hideGeoControlValidationMsg: function (formId) {
      if (!formId) formId = "geo_control";
      var tabName = "p_form_" + formId + "_geoControlValidationMsg";
      var host = $("*[name='" + tabName + "']").closest(".p-form");
      if (host.length) host.css("display", "none");
      var errorDom = $("*[name='" + tabName + "']")
        .parent()
        .siblings("*[name='p_form_error_msg']");
      if (errorDom.length) {
        errorDom.html("");
        errorDom.css("display", "none");
      }
    },
    validateGeoControlNumHh: function (formId) {
      if (!formId) formId = "geo_control";
      var shapeId = ui.custom.console.call.getFormShapeId(formId);
      if (!shapeId) return;

      var levels = ui.custom.console.call.getGeoControlGeoLevels(shapeId) || [];
      if (!levels.length) {
        ui.custom.console.call.setGeoControlValidationPassed(formId, false);
        ui.custom.console.call.showGeoControlValidationMsg(formId, "错误：请先连接“地理层级文件输入”节点，并上传地理层级CSV后再上传 control_totals 文件。");
        return;
      }

      var finest = levels[0];
      var drawBoard = ui.parts.drawBoard.getCurr(ui.custom.console.id);
      var shapeObj = drawBoard && drawBoard.shape ? drawBoard.shape["shape" + shapeId] : null;
      var fieldsMap = (shapeObj && shapeObj.params && shapeObj.params.other && shapeObj.params.other.geoControlControlFields) || {};
      var fields = fieldsMap[finest] || [];
      var hasNumHh = false;
      for (var i = 0; i < fields.length; i++) {
        if ((fields[i] || "").toString().trim().toLowerCase() === "num_hh") {
          hasNumHh = true;
          break;
        }
      }

      if (!hasNumHh) {
        ui.custom.console.call.setGeoControlValidationPassed(formId, false);
        ui.custom.console.call.showGeoControlValidationMsg(
          formId,
          "错误：最细粒度地理层级 <b>" + finest + "</b> 对应的 control_totals 文件必须包含字段 <b>num_hh</b>。"
        );
        return;
      }

      ui.custom.console.call.setGeoControlValidationPassed(formId, true);
      ui.custom.console.call.showGeoControlValidationMsg(
        formId,
        "<span style='color:#1a7f37'>校验成功：最细粒度地理层级 <b>" + finest + "</b> 的 control_totals 已包含 num_hh。</span>"
      );
    },
    parseJsonArraySafe: function (raw) {
      if (!raw) return [];
      try {
        var parsed = JSON.parse(raw);
        return $.isArray(parsed) ? parsed : [];
      } catch (e) {
        return [];
      }
    },
    getShapeSnapshotById: function (shapeId) {
      if (!shapeId) return null;
      var drawBoard = ui.parts.drawBoard.getCurr(ui.custom.console.id);
      if (!drawBoard || !drawBoard.shape || !drawBoard.shape["shape" + shapeId]) return null;
      var shapeObj = drawBoard.shape["shape" + shapeId];
      if (!shapeObj || !shapeObj.params) return null;
      var snap = { id: shapeObj.id, type: shapeObj.params.type || (shapeObj.params.other && shapeObj.params.other.type) };
      if (shapeObj.params.other) {
        for (var otherKey in shapeObj.params.other) {
          if (shapeObj.params.other.hasOwnProperty(otherKey)) snap[otherKey] = shapeObj.params.other[otherKey];
        }
      }
      return snap;
    },
    getPopRunSeedHouseholdHeaders: function () {
      // Only read upstream data when total_control is connected to pop_run.
      // Columns come from the connected seed_input node's seedHouseholdFile headers (parsed on file selection).
      var self = ui.custom.console.call;
      var popRunShapeId = self.getFormShapeId("pop_run");
      if (!popRunShapeId) return { ok: false, error: "请先拖入“人口生成运行”节点（pop_run）。" };

      var totalNodes = self.getTotalControlConnectedShapeIdsByType(popRunShapeId, "total_control");
      if (!totalNodes || !totalNodes.length) return { ok: false, error: "请先将“总控制输入”节点连接到该节点，以读取上游数据。" };

      var seedNodes = self.getTotalControlConnectedShapeIdsByType(totalNodes[0].id, "seed_input");
      if (!seedNodes || !seedNodes.length) return { ok: false, error: "请先将“调研数据输入”节点连接到已连接的“总控制输入”节点。" };

      var seedSnap = seedNodes[0];
      var hhFileName = seedSnap.seedHouseholdFile || "";
      if (!hhFileName) return { ok: false, error: "请先在“调研数据输入”节点选择家庭调研CSV文件（households）。" };

      var tableKey = self.getFileBaseNameNoExt(hhFileName).replace(/^seed_/i, "");
      var headers = seedSnap.seedTableHeaders && seedSnap.seedTableHeaders[tableKey];
      if (!$.isArray(headers) || !headers.length) {
        return { ok: false, error: "尚未读取到 households CSV 表头，请重新选择家庭调研CSV文件。" };
      }
      return { ok: true, headers: headers.slice(0) };
    },
    initPopRunForm: function (formId) {
      if (!formId) formId = "pop_run";
      if (!$("#p_window_" + formId).length) return;

      var self = ui.custom.console.call;
      var radioName = "p_form_" + formId + "_hasSettingsYaml";
      $("input[name='" + radioName + "']")
        .off("change.popRunSetting click.popRunSetting")
        .on("change.popRunSetting click.popRunSetting", function () {
          // Ensure conditional blocks show/hide immediately.
          ui.parts.form.command(formId, ["settingsYamlFile", "outputColumnsLogic", "outHouseholdsTableName", "outHouseholdsColumnsUI", "outPersonsTableName", "outPersonsColumnsUI"]);
          self.initPopRunForm(formId);
        });

      var selected = $("input[name='" + radioName + "']:checked").val();
      if (selected !== "false") return;

      self.renderPopRunColumnsSelector(formId, "outHouseholdsColumnsUI", "outHouseholdsColumnsData");
      self.renderPopRunColumnsSelector(formId, "outPersonsColumnsUI", "outPersonsColumnsData");
    },
    renderPopRunColumnsSelector: function (formId, uiKey, dataKey) {
      var self = ui.custom.console.call;
      var hostWrap = $("#p_forms_" + formId).find(".pop-run-columns[data-key='" + dataKey + "']");
      var host;
      if (hostWrap.length) {
        host = hostWrap.closest(".p-element");
      } else {
        var elementName = "p_form_" + formId + "_" + uiKey;
        host = $("*[name='" + elementName + "']").closest(".p-element");
        if (!host.length) return;
        host.empty().append('<div class="pop-run-columns" data-key="' + dataKey + '"></div>');
        hostWrap = host.find(".pop-run-columns");
      }

      var inputName = "p_form_" + formId + "_" + dataKey;
      var selected = self.parseJsonArraySafe($("input[name='" + inputName + "']").val());

      var headerInfo = self.getPopRunSeedHouseholdHeaders();
      hostWrap.empty();

      if (!headerInfo.ok) {
        hostWrap.append('<div class="pop-run-columns-empty">' + headerInfo.error + "</div>");
        // Keep existing selected data as-is.
        return;
      }

      var headers = headerInfo.headers || [];
      var headerSet = {};
      for (var i = 0; i < headers.length; i++) headerSet[headers[i]] = true;
      selected = (selected || []).filter(function (v) {
        return headerSet[v];
      });
      $("input[name='" + inputName + "']").val(JSON.stringify(selected));

      var list = $('<div class="pop-run-columns-list"></div>');
      for (var j = 0; j < headers.length; j++) {
        var col = headers[j];
        var checked = selected.indexOf(col) !== -1 ? "checked" : "";
        list.append(
          '<label class="pop-run-col-item"><input class="pop-run-col-cb" type="checkbox" style="width:auto;height:auto;margin-right:6px;" value="' +
            col +
            '" ' +
            checked +
            "> " +
            col +
            "</label>"
        );
      }
      hostWrap.append(list);

      hostWrap.off("change.popRunCols", "input.pop-run-col-cb").on("change.popRunCols", "input.pop-run-col-cb", function () {
        var values = [];
        hostWrap.find("input.pop-run-col-cb:checked").each(function () {
          values.push($(this).val());
        });
        $("input[name='" + inputName + "']").val(JSON.stringify(values));
      });
    },
    geoControlTotalsChecked: function (params) {
      // Read header of control_totals_<LEVEL>.csv and store indicator names on the geo_control node.
      var formId = (params && params.formId) || this.formId || "geo_control";
      var key = (params && params.key) || this.key;
      var file = params && params.file;
      var levelName = (this && this.geoLevelName) || "";

      if (!levelName) return;

      // When file is cleared, clear the cached fields for this level.
      if (!file) {
        if (formId && key) ui.custom.console.call.setShapeOtherValue(formId, key, "");
        ui.custom.console.call.setGeoControlControlFields(levelName, []);
        ui.custom.console.call.refreshTotalControlControlFieldOptions();
        ui.custom.console.call.validateGeoControlNumHh(formId);
        return;
      }

      if (formId && key) ui.custom.console.call.setShapeOtherValue(formId, key, file && file.name ? file.name : "");
      var reader = new FileReader();
      reader.onload = function (evt) {
        var text = (evt.target && evt.target.result) || "";
        var headers = ui.custom.console.call.parseCsvHeader(text);
        // control_totals files: first column = geography id; remaining columns = indicators.
        var indicators = headers.slice(1).filter(function (s) {
          return (s || "").toString().trim();
        });
        ui.custom.console.call.setGeoControlControlFields(levelName, indicators);
        ui.custom.console.call.refreshTotalControlControlFieldOptions();
        ui.custom.console.call.validateGeoControlNumHh(formId);
      };
      reader.onerror = function () {
        ui.custom.console.call.setGeoControlControlFields(levelName, []);
        ui.custom.console.call.refreshTotalControlControlFieldOptions();
        ui.custom.console.call.validateGeoControlNumHh(formId);
      };
      reader.readAsText(file);
    },
    setGeoControlControlFields: function (levelName, fields) {
      var formId = "geo_control";
      var shapeId = this.getFormShapeId(formId);
      if (!shapeId) return;
      var drawBoard = ui.parts.drawBoard.getCurr(ui.custom.console.id);
      if (!drawBoard || !drawBoard.shape || !drawBoard.shape["shape" + shapeId]) return;
      var shapeObj = drawBoard.shape["shape" + shapeId];
      if (!shapeObj.params) shapeObj.params = {};
      if (!shapeObj.params.other) shapeObj.params.other = {};
      if (!shapeObj.params.other.geoControlControlFields) shapeObj.params.other.geoControlControlFields = {};
      if (!$.isArray(fields)) fields = [];
      shapeObj.params.other.geoControlControlFields[levelName] = fields;
    },
    setGeoControlLevels: function (headers) {
      var controlFormId = "geo_control";
      if (!ui.parts.window.verify(controlFormId)) return;
      var headerText = (headers || []).join(", ");
      // form.element.setData skips falsy values, so set the span text directly to allow clearing.
      var tabName = "p_form_" + controlFormId + "_geoControlGeoLevelNames";
      var dom = $("*[name='" + tabName + "']");
      if (dom.length) dom.text(headerText);
      else ui.parts.form.element.setData(controlFormId, "geoControlGeoLevelNames", headerText);
    },
    sanitizeControlLevelKey: function (name) {
      var safe = (name || "").replace(/[^A-Za-z0-9_]+/g, "_");
      safe = safe.replace(/^_+|_+$/g, "");
      return safe || "level";
    },
    updateGeoControlForm: function (headers) {
      if (!configs.formWindows || !configs.formWindows.geo_control) return;
      var controlConfig = configs.formWindows.geo_control;
      if (!controlConfig._baseForm) controlConfig._baseForm = $.extend(true, [], controlConfig.form);

      var levels = headers || [];
      var prevLevels = controlConfig._currentGeoLevels || null;
      if (prevLevels && prevLevels.length === levels.length) {
        var same = true;
        for (var i0 = 0; i0 < levels.length; i0++) {
          if (prevLevels[i0] !== levels[i0]) {
            same = false;
            break;
          }
        }
        // Avoid rebuilding the window when the geo levels did not change; rebuilding clears unsaved inputs.
        if (same) return;
      }
      var baseForm = $.extend(true, [], controlConfig._baseForm);
      // Ensure the validation hint stays at the bottom (after dynamically added control_totals inputs).
      var validationTail = [];
      for (var b = baseForm.length - 1; b >= 0; b--) {
        var k = baseForm[b] && baseForm[b].key;
        if (k === "geoControlValidationPassed" || k === "geoControlValidationMsg") {
          validationTail.unshift(baseForm.splice(b, 1)[0]);
        }
      }
      var usedKeys = {};
      for (var index = 0; index < levels.length; index++) {
        var levelName = levels[index];
        var keySuffix = this.sanitizeControlLevelKey(levelName);
        var elementKey = "geoControlTotals_" + keySuffix;
        if (usedKeys[elementKey]) elementKey = elementKey + "_" + (index + 1);
        usedKeys[elementKey] = true;
        baseForm.push({
          key: elementKey,
          i18n: "geo_control_" + elementKey,
          title: "上传control_totals_" + levelName + ".csv",
          type: "file",
          default: "",
          verify: "",
          help: "提示：上传control_totals_" + levelName + ".csv",
          error: "错误：请查看帮助并检查输入！",
          url: typeof popsimUrl === "function" ? popsimUrl("/upload/controlTotals") : "/upload/controlTotals",
          fileName: "fileBtn",
          upload: "custom.console.call.upload",
          onChecked: "custom.console.call.geoControlTotalsChecked",
          isTotalsFile: true,
          geoLevelName: levelName,
        });
      }
      for (var t = 0; t < validationTail.length; t++) baseForm.push(validationTail[t]);
      controlConfig.form = baseForm;
      controlConfig._currentGeoLevels = levels.slice(0);

      if ($("#p_window_geo_control").length) {
        var wasOpen = $("#p_window_geo_control").css("display") != "none";
        var oldWindowParams = ui.parts.window.getConfig("geo_control");
        var oldOther = (oldWindowParams && oldWindowParams.other) || {};
        var oldFormData = {};
        try {
          oldFormData = ui.parts.form.getData("geo_control") || {};
        } catch (e) {
          oldFormData = {};
        }
        $("#p_window_geo_control").remove();
        ui.custom.console.window.form(controlConfig);
        // Preserve bound shapeId (and any other window.other values) across rebuilds.
        if (oldOther) ui.parts.window.change("geo_control", undefined, undefined, oldOther);
        if (oldOther && oldOther.shapeId) {
          var shapeConfig = ui.parts.drawBoard.shape.getConfig(ui.custom.console.id, oldOther.shapeId);
          if (shapeConfig && shapeConfig.other) {
            // Restore live (unsaved) form values first, then fill missing values from the shape cache.
            var restoreData = $.extend(true, {}, shapeConfig.other, oldFormData);
            ui.parts.form.setData("geo_control", restoreData);
            // Also persist the latest values to the node so they don't disappear on re-open.
            for (var k in oldFormData) if (oldFormData.hasOwnProperty(k)) shapeConfig.other[k] = oldFormData[k];
          }
        }
        // Keep the window open without re-triggering windowOpen (avoids recursion).
        if (wasOpen) {
          $("#p_window_geo_control").css("display", "block");
          $("#p_window_bg").css("display", "block");
        }
        // Re-run validation after rebuild so the state doesn't silently reset.
        ui.custom.console.call.validateGeoControlNumHh("geo_control");
      }
    },
    setTotalControlValidationPassed: function (formId, passed) {
      if (!formId) formId = "total_control";
      var inputName = "p_form_" + formId + "_totalControlValidationPassed";
      $("input[name='" + inputName + "']").val(passed ? "true" : "false");
      // Persist on the bound total_control node so the state survives window rebuilds/re-open.
      ui.custom.console.call.setShapeOtherValue(formId, "totalControlValidationPassed", passed ? "true" : "false");
    },
    showTotalControlValidationMsg: function (formId, html) {
      if (!formId) formId = "total_control";
      var tabName = "p_form_" + formId + "_totalControlValidationMsg";
      var host = $("*[name='" + tabName + "']").closest(".p-form");
      if (host.length) host.css("display", "block");
      var errorDom = $("*[name='" + tabName + "']")
        .parent()
        .siblings("*[name='p_form_error_msg']");
      if (errorDom.length) {
        errorDom.html(html || "");
        errorDom.css("display", html ? "block" : "none");
      }
    },
    hideTotalControlValidationMsg: function (formId) {
      if (!formId) formId = "total_control";
      var tabName = "p_form_" + formId + "_totalControlValidationMsg";
      var host = $("*[name='" + tabName + "']").closest(".p-form");
      if (host.length) host.css("display", "none");
      var errorDom = $("*[name='" + tabName + "']")
        .parent()
        .siblings("*[name='p_form_error_msg']");
      if (errorDom.length) {
        errorDom.html("");
        errorDom.css("display", "none");
      }
    },
    getTotalControlFinestGeoLevel: function (formId) {
      if (!formId) formId = "total_control";
      var shapeId = this.getTotalControlShapeId(formId);
      var connected = this.getTotalControlConnectedShapeIdsByType(shapeId, "geo_control");
      if (!connected.length) return "";
      var levels = this.getGeoControlGeoLevels(connected[0].id) || [];
      return levels.length ? levels[0] : "";
    },
    applyTotalControlFirstRowLock: function (formId) {
      if (!formId) formId = "total_control";
      if (!$("#p_window_" + formId).length) return;

      var finest = this.getTotalControlFinestGeoLevel(formId);
      var rowsWrap = $("#p_forms_" + formId).find(".total-control-rows");
      if (!rowsWrap.length) return;

      // Always clear existing lock markers, then re-apply to the first data row.
      rowsWrap.find(".total-control-row").removeClass("total-control-row-locked");
      rowsWrap.find(".total-control-row-delete").removeClass("total-control-row-delete-disabled");
      rowsWrap.find(".total-control-row-select").prop("disabled", false);

      var firstRow = rowsWrap.find(".total-control-row").not(".total-control-header").first();
      if (!firstRow.length) return;

      if (!finest) {
        // No upstream finest geography -> can't lock or validate.
        firstRow.addClass("total-control-row-locked");
        firstRow.find(".total-control-row-delete").addClass("total-control-row-delete-disabled");
        return;
      }

      firstRow.addClass("total-control-row-locked");
      firstRow.find(".total-control-row-delete").addClass("total-control-row-delete-disabled");

      var geoSelect = firstRow.find(".total-control-row-select[data-field='geography']");
      if (geoSelect.length) {
        if (geoSelect.find("option[value='" + finest + "']").length === 0) {
          geoSelect.append('<option value="' + finest + '">' + finest + "</option>");
        }
        geoSelect.val(finest);
        geoSelect.prop("disabled", true);
      }

      var cfSelect = firstRow.find(".total-control-row-select[data-field='control_field']");
      if (cfSelect.length) {
        var requiredField = "num_hh";
        if (cfSelect.find("option[value='" + requiredField + "']").length === 0) {
          cfSelect.append('<option value="' + requiredField + '">' + requiredField + "</option>");
        }
        cfSelect.val(requiredField);
        cfSelect.prop("disabled", true);
      }
    },
    validateTotalControlConfig: function (formId) {
      var self = this;
      if (!formId) formId = "total_control";

      // Default: fail until proven otherwise.
      self.setTotalControlValidationPassed(formId, false);

      var radioName = "p_form_" + formId + "_hasControlCsv";
      var selected = $("input[name='" + radioName + "']:checked").val();
      var hasControlCsv = selected === "true";

      if (!hasControlCsv) {
        var finest = self.getTotalControlFinestGeoLevel(formId);
        if (!finest) {
          self.showTotalControlValidationMsg(formId, "错误：请先将“地理层级指标控制输入”节点连接到该节点，并确保已读取地理层级。");
          return;
        }

        // Manual rows: enforce row 1 to be (geography=finest, control_field=num_hh) and lock it.
        self.applyTotalControlFirstRowLock(formId);
        self.syncTotalControlRowsData(formId);

        // Disallow empty values in any control condition row.
        var rows = self.getTotalControlRowsData(formId) || [];
        var required = ["target", "geography", "seed_table", "importance", "control_field", "expression"];
        for (var i = 0; i < rows.length; i++) {
          var row = rows[i] || {};
          for (var j = 0; j < required.length; j++) {
            var field = required[j];
            var val = row[field];
            if (val == null || val.toString().trim() === "") {
              self.setTotalControlValidationPassed(formId, false);
              self.showTotalControlValidationMsg(formId, "错误：控制条件不允许空值，请补全第 <b>" + (i + 1) + "</b> 行的 <b>" + field + "</b>。");
              return;
            }
          }
        }

        self.setTotalControlValidationPassed(formId, true);
        self.showTotalControlValidationMsg(
          formId,
          "<span style='color:#1a7f37'>校验成功：控制条件无空值，且已锁定第一行（geography=<b>" + finest + "</b>，control_field=<b>num_hh</b>）。</span>"
        );
        return;
      }

      // Uploaded control.csv: validate that it contains a row where geography=zone and control_field=num_hh.
      self._totalControlValidateEpoch = self._totalControlValidateEpoch || {};
      var token = (self._totalControlValidateEpoch[formId] || 0) + 1;
      self._totalControlValidateEpoch[formId] = token;

      var file = self.getFormSelectedFile(formId, "controlCsvFile");
      if (!file) {
        // If the node already passed previously (and the window is re-opened), keep it passable.
        var snap = self.getShapeSnapshotById(self.getFormShapeId(formId));
        if (snap && snap.totalControlValidationPassed === "true") {
          self.setTotalControlValidationPassed(formId, true);
          self.showTotalControlValidationMsg(formId, "<span style='color:#1a7f37'>已通过 control.csv 校验。</span>");
          return;
        }
        self.showTotalControlValidationMsg(formId, "错误：请选择并上传 control.csv 后再完成。");
        return;
      }

      self.showTotalControlValidationMsg(formId, "<span style='color:#666666'>正在校验...</span>");
      self
        .readFileAsText(file)
        .then(function (text) {
          if (self._totalControlValidateEpoch[formId] !== token) return;
          var headers = self.parseCsvHeader(text || "");
          var norm = headers.map(self.normalizeCsvHeaderKey);
          var geoIdx = norm.indexOf("geography");
          var cfIdx = norm.indexOf("control_field");
          if (geoIdx === -1 || cfIdx === -1) {
            self.showTotalControlValidationMsg(formId, "错误：control.csv 缺少必要字段 geography / control_field。");
            return;
          }

          var lines = (text || "").split(/\r?\n/);
          var started = false;
          var hasNumHh = false;
          var hasCorrect = false;
          var wrongGeos = [];
          var requiredGeoLoose = "zone";

          for (var i = 0; i < lines.length; i++) {
            var line = lines[i];
            if (!started) {
              if (line && line.trim() !== "") started = true;
              continue;
            }
            if (!line || line.trim() === "") continue;
            var cols = self.parseCsvLine(line);
            if (cfIdx >= cols.length) continue;
            var cfVal = self.normalizeHeaderLoose(cols[cfIdx] || "");
            if (cfVal !== "num_hh") continue;
            hasNumHh = true;
            var geoVal = geoIdx < cols.length ? cols[geoIdx] : "";
            var geoLoose = self.normalizeHeaderLoose(geoVal || "");
            if (geoLoose === requiredGeoLoose) {
              hasCorrect = true;
              break;
            }
            var shown = (geoVal || "").toString().trim();
            if (shown && wrongGeos.indexOf(shown) === -1) wrongGeos.push(shown);
          }

          if (!hasNumHh) {
            self.showTotalControlValidationMsg(formId, "错误：control.csv 中未找到 control_field 为 <b>num_hh</b> 的行。");
            return;
          }
          if (!hasCorrect) {
            self.showTotalControlValidationMsg(
              formId,
              "错误：control.csv 中 control_field=num_hh 的行，其 geography 必须为 <b>zone</b>。当前检测到的 geography 值：" +
                (wrongGeos.length ? "<b>" + wrongGeos.join(", ") + "</b>" : "<b>(空)</b>")
            );
            return;
          }

          self.setTotalControlValidationPassed(formId, true);
          self.showTotalControlValidationMsg(
            formId,
            "<span style='color:#1a7f37'>校验成功：control.csv 已包含 geography=<b>zone</b> 且 control_field=<b>num_hh</b> 的行。</span>"
          );
        })
        .catch(function () {
          if (self._totalControlValidateEpoch[formId] !== token) return;
          self.showTotalControlValidationMsg(formId, "错误：读取 control.csv 失败，请检查文件编码/格式。");
        });
    },
    initTotalControlRows: function (formId) {
      // The original placeholder span gets replaced the first time this runs.
      // On subsequent opens we must find the existing container instead of relying on the removed span.
      var rowsWrap = $("#p_forms_" + formId).find(".total-control-rows");
      var rowsHost;
      if (rowsWrap.length) {
        rowsHost = rowsWrap.closest(".p-element");
      } else {
        var elementName = "p_form_" + formId + "_controlRowList";
        rowsHost = $("*[name='" + elementName + "']").closest(".p-element");
        if (!rowsHost.length) return;
        rowsHost.empty().append('<div class="total-control-rows"></div>');
        rowsWrap = rowsHost.find(".total-control-rows");
      }

      var rows = this.getTotalControlRowsData(formId);
      if (!rows || !rows.length) rows = [this.emptyTotalControlRow()];
      this.renderTotalControlRows(formId, rowsWrap, rows);
      this.bindTotalControlRowEvents(formId, rowsWrap);
      this.toggleTotalControlRowsVisibility(formId, rowsHost);
      this.refreshTotalControlGeographyOptions();
      this.refreshTotalControlSeedTableOptions();
      this.refreshTotalControlControlFieldOptions();
    },
    bindTotalControlRowEvents: function (formId, rowsWrap) {
      var self = this;
      var radioName = "p_form_" + formId + "_hasControlCsv";
      $("input[name='" + radioName + "']")
        .off("change.totalControl click.totalControl")
        .on("change.totalControl click.totalControl", function () {
          self.toggleTotalControlRowsVisibility(formId, rowsWrap.closest(".p-element"));
          ui.parts.form.command(formId, ["controlRowList", "controlCsvFile"]);
          self.syncTotalControlRowsData(formId);
          self.validateTotalControlConfig(formId);
        });

      rowsWrap.off("click.totalControlDelete", ".total-control-row-delete").on("click.totalControlDelete", ".total-control-row-delete", function () {
        var row = $(this).closest(".total-control-row");
        if (row.hasClass("total-control-row-locked")) return;
        row.remove();
        var geoOptions = self.getTotalControlGeoOptions(formId);
        var seedOptions = self.getTotalControlSeedTableOptions(formId);
        if (!rowsWrap.find(".total-control-row").length) {
          var addRow = rowsWrap.find(".total-control-add-row");
          if (addRow.length) addRow.before(self.buildTotalControlRow(self.emptyTotalControlRow(), geoOptions, seedOptions));
          else rowsWrap.append(self.buildTotalControlRow(self.emptyTotalControlRow(), geoOptions, seedOptions)).append(self.buildTotalControlAddRow());
        }
        self.refreshTotalControlRows(rowsWrap);
        self.syncTotalControlRowsData(formId);
        self.validateTotalControlConfig(formId);
        ui.custom.console.call.workspaceMarkDirty();
      });

      rowsWrap.off("click.totalControlAdd", ".total-control-row-add").on("click.totalControlAdd", ".total-control-row-add", function () {
        var geoOptions = self.getTotalControlGeoOptions(formId);
        var seedOptions = self.getTotalControlSeedTableOptions(formId);
        var addRow = rowsWrap.find(".total-control-add-row");
        if (addRow.length) addRow.before(self.buildTotalControlRow(self.emptyTotalControlRow(), geoOptions, seedOptions));
        else rowsWrap.append(self.buildTotalControlRow(self.emptyTotalControlRow(), geoOptions, seedOptions)).append(self.buildTotalControlAddRow());
        self.refreshTotalControlRows(rowsWrap);
        self.syncTotalControlRowsData(formId);
        self.validateTotalControlConfig(formId);
        ui.custom.console.call.workspaceMarkDirty();
      });

      rowsWrap.off("input.totalControlInput", ".total-control-row-input").on("input.totalControlInput", ".total-control-row-input", function () {
        self.syncTotalControlRowsData(formId);
        self.validateTotalControlConfig(formId);
      });

      rowsWrap.off("change.totalControlSelect", ".total-control-row-select").on("change.totalControlSelect", ".total-control-row-select", function () {
        var field = $(this).data("field");
        if (field === "geography") {
          var rowDom = $(this).closest(".total-control-row");
          self.refreshTotalControlControlFieldOptionsForRow(formId, rowDom);
        }
        // Seed table affects expression autocomplete; close any open suggestions.
        if (field === "seed_table") self.hideTotalControlExpressionSuggest();
        self.syncTotalControlRowsData(formId);
        self.validateTotalControlConfig(formId);
      });

      rowsWrap
        .off("keyup.totalControlExpr", ".total-control-row-input[data-field='expression']")
        .on("keyup.totalControlExpr", ".total-control-row-input[data-field='expression']", function (e) {
          var key = e && (e.key || e.keyCode);
          if (key === "." || key === 190 || key === 110) {
            self.showTotalControlExpressionSuggest(formId, $(this));
          } else if (key === "Escape" || key === 27) {
            self.hideTotalControlExpressionSuggest();
          }
        })
        .off("blur.totalControlExpr", ".total-control-row-input[data-field='expression']")
        .on("blur.totalControlExpr", ".total-control-row-input[data-field='expression']", function () {
          // Delay hiding to allow click selection inside the suggest popup.
          setTimeout(function () {
            ui.custom.console.call.hideTotalControlExpressionSuggest();
          }, 120);
        });
    },
    renderTotalControlRows: function (formId, rowsWrap, rows) {
      rowsWrap.empty();
      rowsWrap.append(this.buildTotalControlHeaderRow());
      var geoOptions = this.getTotalControlGeoOptions(formId);
      var seedOptions = this.getTotalControlSeedTableOptions(formId);
      for (var index = 0; index < rows.length; index++) {
        rowsWrap.append(this.buildTotalControlRow(rows[index], geoOptions, seedOptions));
      }
      rowsWrap.append(this.buildTotalControlAddRow());
      this.refreshTotalControlRows(rowsWrap);
      this.setTotalControlRowsData(formId, rows);
    },
    refreshTotalControlRows: function (rowsWrap) {
      var header = rowsWrap.find(".total-control-header");
      if (header.length) rowsWrap.prepend(header);
      var addRow = rowsWrap.find(".total-control-add-row");
      if (addRow.length) rowsWrap.append(addRow);
      else rowsWrap.append(this.buildTotalControlAddRow());
      var rows = rowsWrap.find(".total-control-row");
      for (var index = 0; index < rows.length; index++) {
        var row = $(rows[index]);
        row.find(".total-control-row-index").text(index + 1);
      }
    },
    buildTotalControlHeaderRow: function () {
      var fields = ["target", "geography", "seed_table", "importance", "control_field", "expression"];
      var row = $('<div class="total-control-header total-control-grid"></div>');
      row.append('<div class="total-control-cell total-control-cell-spacer"></div>');
      row.append('<div class="total-control-cell total-control-cell-index"></div>');
      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        var label = $('<div class="total-control-cell total-control-header-cell"></div>');
        label.text(field);
        label.attr("data-field", field);
        row.append(label);
      }
      return row;
    },
    buildTotalControlRow: function (rowData, geoOptions, seedOptions) {
      var fields = ["target", "geography", "seed_table", "importance", "control_field", "expression"];
      var row = $('<div class="total-control-row total-control-grid"></div>');
      var deleteBtn = $('<div class="total-control-cell total-control-row-delete" title="delete">×</div>');
      var index = $('<div class="total-control-cell total-control-row-index"></div>');
      row.append(deleteBtn).append(index);
      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        if (field == "geography") {
          row.append(this.buildTotalControlGeographySelect(rowData, geoOptions));
        } else if (field == "seed_table") {
          row.append(this.buildTotalControlSeedTableSelect(rowData, seedOptions));
        } else if (field == "control_field") {
          var geography = rowData && rowData.geography ? rowData.geography : "";
          var options = this.getTotalControlControlFieldOptions("total_control", geography);
          row.append(this.buildTotalControlControlFieldSelect(rowData, options));
        } else {
          var input = $('<input type="text" class="total-control-row-input" />');
          input.attr("data-field", field);
          if (rowData && rowData.hasOwnProperty(field)) input.val(rowData[field]);
          row.append(input);
        }
      }
      return row;
    },
    buildTotalControlGeographySelect: function (rowData, options) {
      var select = $('<select class="total-control-row-select"></select>');
      select.attr("data-field", "geography");
      var levels = options || [];
      select.append('<option value="">请选择</option>');
      for (var i = 0; i < levels.length; i++) {
        var level = levels[i];
        var option = $("<option></option>");
        option.attr("value", level);
        option.text(level);
        select.append(option);
      }
      if (rowData && rowData.hasOwnProperty("geography")) select.val(rowData["geography"]);
      return select;
    },
    buildTotalControlSeedTableSelect: function (rowData, options) {
      var select = $('<select class="total-control-row-select"></select>');
      select.attr("data-field", "seed_table");
      var tables = options || [];
      select.append('<option value="">请选择</option>');
      for (var i = 0; i < tables.length; i++) {
        var table = tables[i];
        var option = $("<option></option>");
        option.attr("value", table);
        option.text(table);
        select.append(option);
      }
      if (rowData && rowData.hasOwnProperty("seed_table")) {
        var v = rowData["seed_table"] || "";
        v = v.toString().replace(/^seed_/i, "");
        select.val(v);
      }
      return select;
    },
    buildTotalControlControlFieldSelect: function (rowData, options) {
      var select = $('<select class="total-control-row-select"></select>');
      select.attr("data-field", "control_field");
      var fields = options || [];
      select.append('<option value="">请选择</option>');
      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        var option = $("<option></option>");
        option.attr("value", field);
        option.text(field);
        select.append(option);
      }
      if (rowData && rowData.hasOwnProperty("control_field")) select.val(rowData["control_field"]);
      return select;
    },
    buildTotalControlAddRow: function () {
      return $('<div class="total-control-add-row"><div class="total-control-row-add" title="add">+</div></div>');
    },
    emptyTotalControlRow: function () {
      return {
        target: "",
        geography: "",
        seed_table: "",
        importance: "",
        control_field: "",
        expression: "",
      };
    },
    syncTotalControlRowsData: function (formId) {
      var rowsWrap = $("#p_forms_" + formId).find(".total-control-rows");
      if (!rowsWrap.length) return;
      var rows = [];
      rowsWrap.find(".total-control-row").each(function () {
        if ($(this).hasClass("total-control-row-header")) return;
        var row = {};
        $(this)
          .find(".total-control-row-input, .total-control-row-select")
          .each(function () {
            var field = $(this).data("field");
            row[field] = $(this).val();
          });
        rows.push(row);
      });
      this.setTotalControlRowsData(formId, rows);
    },
    getFormShapeId: function (formId) {
      var windowParams = ui.parts.window.getConfig(formId);
      var shapeId = windowParams && windowParams.other ? windowParams.other.shapeId : null;
      if (shapeId) return shapeId;
      var cache = ui.custom.console.call._lastShapeIdByForm;
      if (cache && cache[formId]) return cache[formId];
      // Last resort: if there is only one shape of this type on the board, use it.
      var drawBoard = ui.parts.drawBoard.getCurr(ui.custom.console.id);
      if (drawBoard && drawBoard.shape) {
        var candidates = [];
        for (var key in drawBoard.shape) {
          if (!drawBoard.shape.hasOwnProperty(key)) continue;
          var s = drawBoard.shape[key];
          if (s && s.params && s.params.type == formId) candidates.push(s.id);
        }
        if (candidates.length === 1) return candidates[0];
      }
      return null;
    },
    getTotalControlShapeId: function (formId) {
      return this.getFormShapeId(formId);
    },
    getTotalControlConnectedShapeIdsByType: function (shapeId, type) {
      if (!shapeId) return [];
      var drawBoard = ui.parts.drawBoard.getCurr(ui.custom.console.id);
      if (!drawBoard || !drawBoard.connects || !drawBoard.shape) return [];

      var results = [];
      var seen = {};
      for (var connectsKey in drawBoard.connects) {
        if (!drawBoard.connects.hasOwnProperty(connectsKey)) continue;
        var connect = drawBoard.connects[connectsKey];
        if (!connect || !connect.shapes || connect.shapes.length < 2) continue;
        var a = connect.shapes[0] && connect.shapes[0].shapeId;
        var b = connect.shapes[1] && connect.shapes[1].shapeId;
        var otherId = null;
        if (a == shapeId) otherId = b;
        else if (b == shapeId) otherId = a;
        if (otherId == null) continue;
        if (seen[otherId]) continue;
        seen[otherId] = true;

        var shapeObj = drawBoard.shape["shape" + otherId];
        if (!shapeObj || !shapeObj.params) continue;
        var shapeType = shapeObj.params.type || (shapeObj.params.other && shapeObj.params.other.type);
        if (shapeType != type) continue;

        // Return a topo-like snapshot: id/type + flattened `other` props (geoLevels, seedPersonFile, etc).
        var snap = { id: shapeObj.id, type: shapeType };
        if (shapeObj.params.other) {
          for (var otherKey in shapeObj.params.other) {
            if (shapeObj.params.other.hasOwnProperty(otherKey)) snap[otherKey] = shapeObj.params.other[otherKey];
          }
        }
        results.push(snap);
      }

      // Fallback: some older saved graphs may have connects metadata that differs; use the existing topo builder.
      if (results.length) return results;
      try {
        var topo = ui.custom.console.getTopo();
        if (!topo || !topo.length) return [];
        var shapeMap = {};
        for (var i = 0; i < topo.length; i++) shapeMap[topo[i].id] = topo[i];
        var target = shapeMap[shapeId];
        if (!target || !target.connects) return [];
        var connectedIds = [];
        for (var j = 0; j < target.connects.length; j++) {
          var c = target.connects[j];
          if (c.to) connectedIds.push(c.to);
          if (c.from) connectedIds.push(c.from);
        }
        var fallback = [];
        var seen2 = {};
        for (var k = 0; k < connectedIds.length; k++) {
          var id = connectedIds[k];
          if (seen2[id]) continue;
          seen2[id] = true;
          var connected = shapeMap[id];
          if (connected && connected.type == type) fallback.push(connected);
        }
        return fallback;
      } catch (e) {
        return [];
      }
    },
    getTotalControlGeoOptions: function (formId) {
      var shapeId = this.getTotalControlShapeId(formId);
      var connected = this.getTotalControlConnectedShapeIdsByType(shapeId, "geo_control");
      if (!connected.length) return [];
      var levels = [];
      for (var i = 0; i < connected.length; i++) {
        var geoLevels = this.getGeoControlGeoLevels(connected[i].id);
        for (var j = 0; j < geoLevels.length; j++) {
          if (levels.indexOf(geoLevels[j]) === -1) levels.push(geoLevels[j]);
        }
      }
      return levels;
    },
    getTotalControlSeedTableOptions: function (formId) {
      var shapeId = this.getTotalControlShapeId(formId);
      var connected = this.getTotalControlConnectedShapeIdsByType(shapeId, "seed_input");
      if (!connected.length) return [];
      var tables = [];
      for (var i = 0; i < connected.length; i++) {
        var item = connected[i];
        if (item.seedPersonFile) tables.push(item.seedPersonFile);
        if (item.seedHouseholdFile) tables.push(item.seedHouseholdFile);
      }
      var cleaned = [];
      for (var j = 0; j < tables.length; j++) {
        var clean = this.getFileBaseNameNoExt(tables[j]);
        clean = clean.replace(/^seed_/i, "");
        if (clean && cleaned.indexOf(clean) === -1) cleaned.push(clean);
      }
      return cleaned;
    },
    getTotalControlSeedTableHeaderOptions: function (formId, seedTable) {
      if (!seedTable) return [];
      var shapeId = this.getTotalControlShapeId(formId);
      var connected = this.getTotalControlConnectedShapeIdsByType(shapeId, "seed_input");
      if (!connected.length) return [];
      var options = [];
      for (var i = 0; i < connected.length; i++) {
        var item = connected[i];
        var map = item && item.seedTableHeaders ? item.seedTableHeaders : null;
        if (!map) continue;
        var headers = map[seedTable];
        if (!$.isArray(headers)) continue;
        for (var j = 0; j < headers.length; j++) {
          var v = (headers[j] || "").toString().trim();
          if (v && options.indexOf(v) === -1) options.push(v);
        }
      }
      return options;
    },
    getTotalControlControlFieldOptions: function (formId, geographyLevel) {
      if (!geographyLevel) return [];
      var shapeId = this.getTotalControlShapeId(formId);
      var connected = this.getTotalControlConnectedShapeIdsByType(shapeId, "geo_control");
      if (!connected.length) return [];

      var options = [];
      for (var i = 0; i < connected.length; i++) {
        var geoControl = connected[i];
        var map = geoControl && geoControl.geoControlControlFields ? geoControl.geoControlControlFields : null;
        if (!map) continue;
        var list = map[geographyLevel];
        if (!$.isArray(list)) continue;
        for (var j = 0; j < list.length; j++) {
          var v = (list[j] || "").toString().trim();
          if (v && options.indexOf(v) === -1) options.push(v);
        }
      }
      return options;
    },
    getFileBaseNameNoExt: function (filePath) {
      if (!filePath) return "";
      var name = filePath.toString();
      // Handle local browser fake path (C:\fakepath\foo.csv) and unix paths.
      name = name.replace(/^.*[\\/]/, "");
      name = name.replace(/\.[^/.]+$/, "");
      return name;
    },
    setShapeOtherValue: function (formId, key, value) {
      var shapeId = this.getFormShapeId(formId);
      if (!shapeId) return;
      var drawBoard = ui.parts.drawBoard.getCurr(ui.custom.console.id);
      if (!drawBoard || !drawBoard.shape || !drawBoard.shape["shape" + shapeId]) return;
      var shapeObj = drawBoard.shape["shape" + shapeId];
      if (!shapeObj.params) shapeObj.params = {};
      if (!shapeObj.params.other) shapeObj.params.other = {};
      shapeObj.params.other[key] = value;
    },
    setGeoLevelsOnShape: function (formId, headers) {
      var shapeId = this.getFormShapeId(formId);
      if (!shapeId) return;
      var drawBoard = ui.parts.drawBoard.getCurr(ui.custom.console.id);
      if (!drawBoard || !drawBoard.shape || !drawBoard.shape["shape" + shapeId]) return;
      var shapeObj = drawBoard.shape["shape" + shapeId];
      if (!shapeObj.params) shapeObj.params = {};
      if (!shapeObj.params.other) shapeObj.params.other = {};
      if (!$.isArray(headers)) headers = [];
      shapeObj.params.other.geoLevels = headers;
      shapeObj.params.other.geoLevelNames = headers.join(", ");
      shapeObj.params.other.geoLevelCount = headers.length.toString();
    },
    setSeedTableHeadersOnShape: function (formId, tableKey, headers) {
      var shapeId = this.getFormShapeId(formId);
      if (!shapeId) return;
      if (!tableKey) return;
      var drawBoard = ui.parts.drawBoard.getCurr(ui.custom.console.id);
      if (!drawBoard || !drawBoard.shape || !drawBoard.shape["shape" + shapeId]) return;
      var shapeObj = drawBoard.shape["shape" + shapeId];
      if (!shapeObj.params) shapeObj.params = {};
      if (!shapeObj.params.other) shapeObj.params.other = {};
      if (!shapeObj.params.other.seedTableHeaders) shapeObj.params.other.seedTableHeaders = {};
      if (!$.isArray(headers)) headers = [];
      shapeObj.params.other.seedTableHeaders[tableKey] = headers;
    },
    getGeoControlGeoLevels: function (geoControlShapeId) {
      if (!geoControlShapeId) return [];
      var geoNodes = this.getTotalControlConnectedShapeIdsByType(geoControlShapeId, "geo");
      var levels = [];
      for (var i = 0; i < geoNodes.length; i++) {
        var geoNode = geoNodes[i];
        var nodeLevels = [];
        if ($.isArray(geoNode.geoLevels) && geoNode.geoLevels.length) {
          nodeLevels = geoNode.geoLevels;
        } else if (geoNode.geoLevelNames && typeof geoNode.geoLevelNames == "string") {
          nodeLevels = geoNode.geoLevelNames
            .split(",")
            .map(function (s) {
              return s.trim();
            })
            .filter(function (s) {
              return s;
            });
        } else if ($.isArray(ui.custom.console.geoLevels) && ui.custom.console.geoLevels.length) {
          // Fallback for older sessions where levels were only stored globally.
          nodeLevels = ui.custom.console.geoLevels;
        }
        for (var j = 0; j < nodeLevels.length; j++) {
          if (levels.indexOf(nodeLevels[j]) === -1) levels.push(nodeLevels[j]);
        }
        if (nodeLevels.length) {
          var drawBoard = ui.parts.drawBoard.getCurr(ui.custom.console.id);
          if (drawBoard && drawBoard.shape && drawBoard.shape["shape" + geoNode.id]) {
            if (!drawBoard.shape["shape" + geoNode.id].params.other) drawBoard.shape["shape" + geoNode.id].params.other = {};
            drawBoard.shape["shape" + geoNode.id].params.other.geoLevels = nodeLevels;
          }
        }
      }
      return levels;
    },
    refreshTotalControlGeographyOptions: function () {
      var formId = "total_control";
      if (!ui.parts.window.verify(formId)) return;
      var rowsWrap = $("#p_forms_" + formId).find(".total-control-rows");
      if (!rowsWrap.length) return;
      var geoOptions = this.getTotalControlGeoOptions(formId);
      rowsWrap.find(".total-control-row-select").each(function () {
        var current = $(this).val();
        var field = $(this).data("field");
        if (field == "geography") $(this).replaceWith(ui.custom.console.call.buildTotalControlGeographySelect({ geography: current }, geoOptions));
      });
      this.bindTotalControlRowEvents(formId, rowsWrap);
    },
    refreshTotalControlSeedTableOptions: function () {
      var formId = "total_control";
      if (!ui.parts.window.verify(formId)) return;
      var rowsWrap = $("#p_forms_" + formId).find(".total-control-rows");
      if (!rowsWrap.length) return;
      var seedOptions = this.getTotalControlSeedTableOptions(formId);
      rowsWrap.find(".total-control-row-select").each(function () {
        var current = $(this).val();
        var field = $(this).data("field");
        if (field == "seed_table") $(this).replaceWith(ui.custom.console.call.buildTotalControlSeedTableSelect({ seed_table: current }, seedOptions));
      });
      this.bindTotalControlRowEvents(formId, rowsWrap);
    },
    refreshTotalControlControlFieldOptionsForRow: function (formId, rowDom) {
      if (!rowDom || !rowDom.length) return;
      var geography = rowDom.find(".total-control-row-select[data-field='geography']").val() || "";
      var current =
        rowDom.find(".total-control-row-select[data-field='control_field']").val() ||
        rowDom.find(".total-control-row-input[data-field='control_field']").val() ||
        "";
      var options = this.getTotalControlControlFieldOptions(formId, geography);
      var target = rowDom.find("[data-field='control_field']");
      if (target.length) target.first().replaceWith(this.buildTotalControlControlFieldSelect({ control_field: current }, options));
    },
    refreshTotalControlControlFieldOptions: function () {
      var formId = "total_control";
      if (!ui.parts.window.verify(formId)) return;
      var rowsWrap = $("#p_forms_" + formId).find(".total-control-rows");
      if (!rowsWrap.length) return;
      var self = this;
      rowsWrap.find(".total-control-row").each(function () {
        self.refreshTotalControlControlFieldOptionsForRow(formId, $(this));
      });
      this.bindTotalControlRowEvents(formId, rowsWrap);
    },
    ensureTotalControlExpressionSuggest: function () {
      this._exprSuggest = this._exprSuggest || {};
      if (this._exprSuggest.box && this._exprSuggest.box.length) return;

      var box = $("#total_control_expr_suggest");
      if (!box.length) {
        box = $('<div id="total_control_expr_suggest" class="total-control-expr-suggest"></div>');
        $("body").append(box);
      }
      box.hide();

      this._exprSuggest.box = box;
      var self = this;

      box.off("mousedown.exprSuggest").on("mousedown.exprSuggest", ".total-control-expr-suggest-item", function (e) {
        e.preventDefault();
        var value = $(this).data("value");
        var input = self._exprSuggest && self._exprSuggest.input ? self._exprSuggest.input : null;
        if (input && input.length) {
          self.insertTextAtCursor(input[0], value);
          input.trigger("input");
          input.focus();
        }
        self.hideTotalControlExpressionSuggest();
      });

      $(document)
        .off("mousedown.exprSuggestDoc")
        .on("mousedown.exprSuggestDoc", function (e) {
          var boxEl = self._exprSuggest && self._exprSuggest.box ? self._exprSuggest.box[0] : null;
          var inputEl = self._exprSuggest && self._exprSuggest.input ? self._exprSuggest.input[0] : null;
          if (!boxEl) return;
          if (boxEl.contains(e.target)) return;
          if (inputEl && inputEl === e.target) return;
          self.hideTotalControlExpressionSuggest();
        });
    },
    showTotalControlExpressionSuggest: function (formId, inputDom) {
      if (!inputDom || !inputDom.length) return;
      this.ensureTotalControlExpressionSuggest();

      var rowDom = inputDom.closest(".total-control-row");
      var seedTable = rowDom.find(".total-control-row-select[data-field='seed_table']").val() || "";
      if (!seedTable) return this.hideTotalControlExpressionSuggest();

      var headers = this.getTotalControlSeedTableHeaderOptions(formId, seedTable);
      if (!headers.length) return this.hideTotalControlExpressionSuggest();

      var box = this._exprSuggest.box;
      box.empty();
      for (var i = 0; i < headers.length; i++) {
        var item = $('<div class="total-control-expr-suggest-item"></div>');
        item.text(headers[i]);
        item.data("value", headers[i]);
        box.append(item);
      }

      var offset = inputDom.offset();
      var top = (offset ? offset.top : 0) + inputDom.outerHeight() + 2;
      var left = offset ? offset.left : 0;
      var width = Math.max(inputDom.outerWidth(), 220);
      box.css({ top: top, left: left, width: width + "px" }).show();

      this._exprSuggest.input = inputDom;
      this._exprSuggest.formId = formId;
    },
    hideTotalControlExpressionSuggest: function () {
      if (this._exprSuggest && this._exprSuggest.box) this._exprSuggest.box.hide();
      if (this._exprSuggest) this._exprSuggest.input = null;
    },
    insertTextAtCursor: function (inputEl, text) {
      if (!inputEl || text == null) return;
      var value = inputEl.value || "";
      try {
        var start = inputEl.selectionStart;
        var end = inputEl.selectionEnd;
        if (typeof start !== "number" || typeof end !== "number") {
          inputEl.value = value + text;
          return;
        }
        inputEl.value = value.slice(0, start) + text + value.slice(end);
        var pos = start + text.length;
        if (inputEl.setSelectionRange) inputEl.setSelectionRange(pos, pos);
      } catch (e) {
        inputEl.value = value + text;
      }
    },
    setTotalControlRowsData: function (formId, rows) {
      var inputName = "p_form_" + formId + "_controlRowsData";
      $("input[name='" + inputName + "']").val(JSON.stringify(rows || []));
    },
    getTotalControlRowsData: function (formId) {
      var inputName = "p_form_" + formId + "_controlRowsData";
      var raw = $("input[name='" + inputName + "']").val();
      if (!raw) return [];
      try {
        var parsed = JSON.parse(raw);
        return $.isArray(parsed) ? parsed : [];
      } catch (e) {
        return [];
      }
    },
    toggleTotalControlRowsVisibility: function (formId, rowsHost) {
      var radioName = "p_form_" + formId + "_hasControlCsv";
      var selected = $("input[name='" + radioName + "']:checked").val();
      var showRows = selected === "false";
      var host = rowsHost || $("#p_forms_" + formId).find(".total-control-rows").closest(".p-element");
      if (!host.length) return;
      host.closest(".p-form").css("display", showRows ? "block" : "none");
    },
    parseCsvHeader: function (text) {
      if (!text) return [];
      var lines = text.split(/\r?\n/);
      var line = "";
      for (var index = 0; index < lines.length; index++) {
        if (lines[index].trim() !== "") {
          line = lines[index];
          break;
        }
      }
      if (!line) return [];
      if (line.charAt(0) === "\ufeff") line = line.slice(1);

      var headers = [];
      var current = "";
      var inQuotes = false;
      for (var i = 0; i < line.length; i++) {
        var ch = line.charAt(i);
        if (ch === '"') {
          if (inQuotes && line.charAt(i + 1) === '"') {
            current += '"';
            i++;
          } else {
            inQuotes = !inQuotes;
          }
        } else if (ch === "," && !inQuotes) {
          headers.push(current);
          current = "";
        } else {
          current += ch;
        }
      }
      headers.push(current);

      for (var j = 0; j < headers.length; j++) {
        var value = headers[j].trim();
        if (value.charAt(0) === '"' && value.charAt(value.length - 1) === '"') {
          value = value.slice(1, -1);
        }
        headers[j] = value;
      }

      return headers;
    }
  });
})();
